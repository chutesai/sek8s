---
- name: Check if nbd device is connected
  ansible.builtin.command: qemu-nbd --check {{ nbd_device }}
  register: nbd_check_result
  failed_when: false
  changed_when: false

- name: Disconnect nbd device if connected
  ansible.builtin.command: qemu-nbd --disconnect {{ nbd_device }}
  when: nbd_check_result.rc == 0
  register: nbd_disconnect_result
  changed_when: nbd_disconnect_result.rc == 0
  ignore_errors: true

- name: Unmount all possible partitions if mounted
  ansible.builtin.mount:
    path: "{{ item }}"
    state: unmounted
  ignore_errors: true
  loop:
    - "{{ newroot_mount }}/sys/firmware/efi/efivars"
    - "{{ newroot_mount }}/proc"
    - "{{ newroot_mount }}/sys"
    - "{{ newroot_mount }}/dev"
    - "{{ newroot_mount }}/run"
    - "{{ newroot_mount }}/boot/efi"
    - "{{ newroot_mount }}/boot"
    - "{{ newroot_mount }}"

- name: Clean up temporary directories if leftover
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  ignore_errors: true
  loop:
    - "{{ newroot_mount }}"

- name: Load nbd kernel module
  ansible.builtin.command: modprobe nbd max_part=8
  args:
    creates: /dev/nbd0
  register: modprobe_result
  changed_when: modprobe_result.rc == 0

- name: Connect qcow2 image to nbd device
  ansible.builtin.command: qemu-nbd --connect={{ nbd_device }} {{ final_img_path }}
  args:
    creates: "{{ nbd_device }}p1"
  register: qemu_nbd_result
  changed_when: qemu_nbd_result.rc == 0

- name: Run partprobe to detect partitions
  ansible.builtin.command: partprobe {{ nbd_device }}
  changed_when: false

- name: Create mount point
  ansible.builtin.file:
    path: "{{ newroot_mount }}"
    state: directory
    mode: '0755'

- name: Detect partition layout dynamically
  ansible.builtin.shell: |
    set -e
    
    efi=""
    boot=""
    root=""
    
    # Iterate through all partitions
    for part in {{ nbd_device }}p*; do
      fstype=$(blkid -o value -s TYPE "$part" 2>/dev/null || echo "")
      size=$(blockdev --getsize64 "$part" 2>/dev/null || echo "0")
      size_mb=$((size / 1024 / 1024))
      
      case "$fstype" in
        vfat)
          # EFI partition
          efi="$part"
          ;;
        ext4)
          # Distinguish boot vs root by size
          if [ $size_mb -lt 2048 ]; then
            # Small ext4 (< 2GB) is /boot
            boot="$part"
          else
            # Large ext4 is root
            root="$part"
          fi
          ;;
      esac
    done
    
    # Validation
    if [ -z "$efi" ]; then
      echo "ERROR: Could not detect EFI partition" >&2
      exit 1
    fi
    if [ -z "$root" ]; then
      echo "ERROR: Could not detect root partition" >&2
      exit 1
    fi
    if [ -z "$boot" ]; then
      echo "ERROR: Could not detect boot partition" >&2
      exit 1
    fi
    
    echo "efi=$efi"
    echo "boot=$boot"
    echo "root=$root"
  args:
    executable: /bin/bash
  register: partition_detection
  changed_when: false
  failed_when: partition_detection.rc != 0

- name: Parse detected partitions
  ansible.builtin.set_fact:
    efi_partition: "{{ partition_detection.stdout | regex_search('efi=([^\\s]+)', '\\1') | first }}"
    boot_partition: "{{ partition_detection.stdout | regex_search('boot=([^\\s]+)', '\\1') | first }}"
    root_partition: "{{ partition_detection.stdout | regex_search('root=([^\\s]+)', '\\1') | first }}"

- name: Display detected partition layout
  ansible.builtin.debug:
    msg:
      - "Detected partition layout:"
      - "  EFI:  {{ efi_partition }}"
      - "  Boot: {{ boot_partition }}"
      - "  Root: {{ root_partition }}"

- name: Mount root partition
  ansible.builtin.mount:
    path: "{{ newroot_mount }}"
    src: "{{ root_partition }}"
    fstype: ext4
    state: ephemeral

- name: Mount boot partition
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/boot"
    src: "{{ boot_partition }}"
    fstype: ext4
    state: ephemeral

- name: Mount EFI partition
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/boot/efi"
    src: "{{ efi_partition }}"
    fstype: vfat
    state: ephemeral

- name: Bind mount system directories
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/{{ item }}"
    src: "/{{ item }}"
    fstype: none
    opts: bind
    state: ephemeral
  loop:
    - proc
    - sys
    - dev
    - run

# Install TDX quote generator and dependencies
- name: Install build dependencies in chroot
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      apt-get update &&
      apt-get install -y build-essential curl dhcpcd-base cryptsetup e2fsprogs ca-certificates openssl vim-tiny nano
    "
  register: chroot_deps_result
  changed_when: chroot_deps_result.rc == 0

- name: Copy TDX initramfs hooks
  ansible.builtin.copy:
    src: files/initramfs/fetch_key
    dest: "{{ newroot_mount }}/etc/initramfs-tools/hooks/fetch_key"
    mode: '0755'
    owner: root
    group: root

- name: Copy TDX module loader script (init-top)
  ansible.builtin.copy:
    src: files/initramfs/load-tdx
    dest: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-top/load-tdx"
    mode: '0755'
    owner: root
    group: root

- name: Copy TDX unlock script (init-premount) - Modified to skip LUKS
  ansible.builtin.copy:
    src: files/initramfs/fetch_key_and_unlock
    dest: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-premount/fetch_key_and_unlock"
    mode: '0755'
    owner: root
    group: root

- name: Create TDX environment configuration
  ansible.builtin.copy:
    content: |
      # TDX LUKS Configuration (for testing)
      TDX_API_ENDPOINT="{{ tdx_api_endpoint | default('https://api.chutes.ai/servers/boot/attestation') }}"
      TDX_NONCE_ENDPOINT="{{ tdx_nonce_endpoint | default('https://api.chutes.ai/servers/nonce') }}"
      LUKS_DEVICE="{{ root_partition }}"
      LUKS_NAME="encrypted_root"
      TDX_TIMEOUT="30"
      TDX_RETRY_COUNT="3"
    dest: "{{ newroot_mount }}/etc/tdx-luks.conf"
    mode: '0644'
    owner: root
    group: root

- name: Enable serial console and debug in GRUB
  ansible.builtin.lineinfile:
    path: "{{ newroot_mount }}/etc/default/grub"
    regexp: '^GRUB_CMDLINE_LINUX_DEFAULT='
    line: 'GRUB_CMDLINE_LINUX_DEFAULT="console=ttyS0,115200n8"'
    backup: yes

- name: Enable serial console in GRUB terminal
  ansible.builtin.lineinfile:
    path: "{{ newroot_mount }}/etc/default/grub"
    regexp: '^#?GRUB_TERMINAL='
    line: 'GRUB_TERMINAL="serial console"'

- name: Configure GRUB serial command
  ansible.builtin.lineinfile:
    path: "{{ newroot_mount }}/etc/default/grub"
    regexp: '^#?GRUB_SERIAL_COMMAND='
    line: 'GRUB_SERIAL_COMMAND="serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1"'

- name: Update initramfs and grub in chroot
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      update-initramfs -u -k all &&
      update-grub
    "
  register: chroot_update_result
  changed_when: chroot_update_result.rc == 0

- name: Verify initramfs contents
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      echo '=== Checking for required files in initramfs ===' &&
      lsinitramfs /boot/initrd.img-\$(uname -r) | grep -E '(openssl|fetch_key_and_unlock|load-tdx|bin/vi|bin/nano)' | sort ||
      echo 'WARNING: Some files not found in initramfs'
    "
  register: initramfs_check
  changed_when: false

- name: Display initramfs verification
  ansible.builtin.debug:
    var: initramfs_check.stdout_lines

- name: Unmount system directories
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/{{ item }}"
    state: unmounted
  loop:
    - sys/firmware/efi/efivars
    - proc
    - sys
    - dev
    - run
    - boot/efi
    - boot
    - ""

- name: Disconnect nbd device
  ansible.builtin.command: qemu-nbd --disconnect {{ nbd_device }}
  args:
    removes: "{{ nbd_device }}"
  register: qemu_nbd_disconnect_result
  changed_when: qemu_nbd_disconnect_result.rc == 0

- name: Clean up temporary directories
  ansible.builtin.file:
    path: "{{ newroot_mount }}"
    state: absent