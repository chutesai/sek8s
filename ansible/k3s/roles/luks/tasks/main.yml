---
- name: Check if LUKS container is open
  ansible.builtin.stat:
    path: "/dev/mapper/{{ encrypted_root_name }}"
  register: luks_stat

- name: Close LUKS container if open
  community.crypto.luks_device:
    name: "{{ encrypted_root_name }}"
    state: closed
  when: luks_stat.stat.exists
  ignore_errors: true  # Ignore errors if already closed or not present

- name: Check if nbd device is connected
  ansible.builtin.command: qemu-nbd --check {{ nbd_device }}
  register: nbd_check_result
  failed_when: false  # Donâ€™t fail if not connected
  changed_when: false

- name: Disconnect nbd device if connected
  ansible.builtin.command: qemu-nbd --disconnect {{ nbd_device }}
  when: nbd_check_result.rc == 0  # Only run if device is connected
  register: nbd_disconnect_result
  changed_when: nbd_disconnect_result.rc == 0
  ignore_errors: true  # Ignore errors if disconnect fails

- name: Unmount all possible partitions if mounted (cleanup from previous runs)
  ansible.builtin.mount:
    path: "{{ item }}"
    state: unmounted
  ignore_errors: true  # Ignore if not mounted or busy
  loop:
    - "{{ newroot_mount }}/sys/firmware/efi/efivars"
    - "{{ newroot_mount }}/proc"
    - "{{ newroot_mount }}/sys"
    - "{{ newroot_mount }}/dev"
    - "{{ newroot_mount }}/run"
    - "{{ newroot_mount }}/boot/efi"
    - "{{ newroot_mount }}/boot"
    - "{{ newroot_mount }}"
    - "{{ root_mount }}/boot/efi"
    - "{{ root_mount }}/boot"
    - "{{ root_mount }}"

- name: Clean up temporary directories if leftover
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  ignore_errors: true
  loop:
    - "{{ root_mount }}"
    - "{{ newroot_mount }}"
    - "{{ backup_dir }}"

- name: Load nbd kernel module
  ansible.builtin.command: modprobe nbd max_part=8
  args:
    creates: /dev/nbd0
  register: modprobe_result
  changed_when: modprobe_result.rc == 0

- name: Connect qcow2 image to nbd device
  ansible.builtin.command: qemu-nbd --connect={{ nbd_device }} {{ final_img_path }}
  args:
    creates: "{{ nbd_device }}p1"
  register: qemu_nbd_result
  changed_when: qemu_nbd_result.rc == 0

- name: Run partprobe to detect partitions
  ansible.builtin.command: partprobe {{ nbd_device }}
  changed_when: false

- name: Check if backup already exists
  ansible.builtin.stat:
    path: "{{ backup_dir }}/etc"
  register: backup_stat

- name: Create mount points
  ansible.builtin.file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ root_mount }}"
    - "{{ backup_dir }}"
    - "{{ newroot_mount }}"

- name: Mount root partition
  ansible.builtin.mount:
    path: "{{ root_mount }}"
    src: "{{ root_partition }}"
    fstype: ext4
    state: mounted
  when: not backup_stat.stat.exists

- name: Mount boot partition
  ansible.builtin.mount:
    path: "{{ root_mount }}/boot"
    src: "{{ boot_partition }}"
    fstype: ext4
    state: mounted
  when: not backup_stat.stat.exists

- name: Mount EFI partition
  ansible.builtin.mount:
    path: "{{ root_mount }}/boot/efi"
    src: "{{ efi_partition }}"
    fstype: vfat
    state: mounted
  when: not backup_stat.stat.exists

- name: Backup root filesystem
  ansible.builtin.command: rsync -aAXv {{ root_mount }}/ {{ backup_dir }}/
  args:
    creates: "{{ backup_dir }}/etc"
  register: rsync_backup_result
  changed_when: rsync_backup_result.rc == 0
  when: not backup_stat.stat.exists

- name: Unmount partitions
  ansible.builtin.mount:
    path: "{{ item }}"
    state: unmounted
  loop:
    - "{{ root_mount }}/boot/efi"
    - "{{ root_mount }}/boot"
    - "{{ root_mount }}"
  when: not backup_stat.stat.exists

- name: Create LUKS keyfile
  ansible.builtin.copy:
    content: "{{ luks_passphrase | mandatory }}"
    dest: /tmp/luks_keyfile
    mode: '0600'
    owner: root
    group: root

- name: Wipe existing superblock (optional, for safety)
  ansible.builtin.command: wipefs -a {{ root_partition }}
  register: wipefs_result
  changed_when: wipefs_result.rc == 0
  failed_when: wipefs_result.rc != 0

- name: Create LUKS container
  community.crypto.luks_device:
    device: "{{ root_partition }}"
    state: present
    passphrase: "{{ luks_passphrase }}"
  no_log: true  # Hide passphrase in logs

- name: Open LUKS container
  community.crypto.luks_device:
    device: "{{ root_partition }}"
    state: opened
    name: "{{ encrypted_root_name }}"
    passphrase: "{{ luks_passphrase }}"
  no_log: true

- name: Create ext4 filesystem on LUKS partition
  ansible.builtin.filesystem:
    dev: /dev/mapper/{{ encrypted_root_name }}
    fstype: ext4

- name: Mount encrypted root
  ansible.builtin.mount:
    path: "{{ newroot_mount }}"
    src: "/dev/mapper/{{ encrypted_root_name }}"
    fstype: ext4
    state: mounted

- name: Restore data to encrypted root
  ansible.builtin.command: rsync -aAXv {{ backup_dir }}/ {{ newroot_mount }}/
  args:
    creates: "{{ newroot_mount }}/etc"
  register: rsync_restore_result
  changed_when: rsync_restore_result.rc == 0

- name: Mount boot partition to new root
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/boot"
    src: "{{ boot_partition }}"
    fstype: ext4
    state: mounted

- name: Mount EFI partition to new root
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/boot/efi"
    src: "{{ efi_partition }}"
    fstype: vfat
    state: mounted

- name: Bind mount system directories
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/{{ item }}"
    src: "/{{ item }}"
    fstype: none
    opts: bind
    state: mounted
  loop:
    - proc
    - sys
    - dev
    - run

- name: Chroot and install cryptsetup and e2fsprogs
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      apt-get update &&
      apt-get install -y cryptsetup e2fsprogs
    "
  register: chroot_install_result
  changed_when: chroot_install_result.rc == 0

- name: Get UUID of LUKS partition
  ansible.builtin.command: blkid -o value -s UUID {{ root_partition }}
  register: blkid_result
  changed_when: false

- name: Update /etc/crypttab
  ansible.builtin.lineinfile:
    path: "{{ newroot_mount }}/etc/crypttab"
    line: "{{ encrypted_root_name }} UUID={{ blkid_result.stdout }} none luks,discard"
    create: yes
    mode: '0644'

- name: Update /etc/fstab
  ansible.builtin.replace:
    path: "{{ newroot_mount }}/etc/fstab"
    regexp: '^LABEL=cloudimg-rootfs\s+/\s+ext4\s+discard,commit=30,errors=remount-ro\s+0\s+1$'
    replace: '/dev/mapper/{{ encrypted_root_name }}\t/\text4\tdiscard,errors=remount-ro\t0 1'
    backup: yes

- name: Copy fetch_key hooks
  ansible.builtin.copy:
    src: files/initramfs/fetch_key
    dest: "{{ newroot_mount }}/etc/initramfs-tools/hooks/fetch_key"
    mode: '0755'
    owner: root
    group: root

- name: Copy fetch_key script
  ansible.builtin.copy:
    src: files/initramfs/fetch_key_and_unlock
    dest: "{{ newroot_mount }}/etc/initramfs-tools/scripts/init-premount/fetch_key_and_unlock"
    mode: '0755'
    owner: root
    group: root

- name: Update initramfs and grub in chroot
  ansible.builtin.shell: |
    chroot {{ newroot_mount }} /bin/bash -c "
      update-initramfs -u -k all &&
      update-grub
    "
  register: chroot_update_result
  changed_when: chroot_update_result.rc == 0

- name: Unmount system directories
  ansible.builtin.mount:
    path: "{{ newroot_mount }}/{{ item }}"
    state: unmounted
  loop:
    - sys/firmware/efi/efivars
    - proc
    - sys
    - dev
    - run
    - boot/efi
    - boot
    - ""

- name: Close LUKS container
  community.crypto.luks_device:
    name: "{{ encrypted_root_name }}"
    state: closed

- name: Disconnect nbd device
  ansible.builtin.command: qemu-nbd --disconnect {{ nbd_device }}
  args:
    removes: "{{ nbd_device }}"
  register: qemu_nbd_disconnect_result
  changed_when: qemu_nbd_disconnect_result.rc == 0

- name: Clean up temporary directories
  ansible.builtin.file:
    path: "{{ item }}"
    state: absent
  loop:
    - "{{ root_mount }}"
    - "{{ newroot_mount }}"
    - "{{ backup_dir }}"